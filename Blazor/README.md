# .NET 8 'Blazor Web App'  

## Installation/setup

The project was bootstrapped using a .Net 8's 'Blazor Web App' template (short name 'blazor'):

` dotnet new blazor -o Blazor `

dotnet new list
These templates matched your input: 

Template Name                                 Short Name                  Language    Tags                      
--------------------------------------------  --------------------------  ----------  --------------------------
API Controller                                apicontroller               [C#]        Web/ASP.NET               
ASP.NET Core Empty                            web                         [C#],F#     Web/Empty                 
ASP.NET Core gRPC Service                     grpc                        [C#]        Web/gRPC/API/Service      
ASP.NET Core Web API                          webapi                      [C#],F#     Web/Web API/API/Service   
ASP.NET Core Web API (native AOT)             webapiaot                   [C#]        Web/Web API/API/Service   
ASP.NET Core Web App (Model-View-Controller)  mvc                         [C#],F#     Web/MVC                   
ASP.NET Core Web App (Razor Pages)            webapp,razor                [C#]        Web/MVC/Razor Pages       
Blazor Server App                             blazorserver                F#          Web/Blazor                
Blazor Web App                                blazor                      [C#]        Web/Blazor/WebAssembly           <== âˆš  
Blazor WebAssembly Standalone App             blazorwasm                  [C#]        Web/Blazor/WebAssembly/PWA



## Project Structure

### Root Directory
* Blazor.csproj: The C# project file. It contains information about the project, including configurations and references to any dependencies or NuGet packages.
* Blazor.sln: The solution file for Visual Studio. It groups together projects that are related, in this case, likely just your Blazor project, but could include others if your application grows.

### Components Directory
This directory contains the Razor components and pages for your Blazor application, structured in a way to organize code and markup:

* App.razor: The root component for your application. It sets up routing for the app.
* Layout: Contains components used to layout your application, such as the main layout (MainLayout.razor) and navigation menu (NavMenu.razor), along with their associated CSS files.
* Pages: Contains individual page components like Counter.razor and Home.razor, which represent different views or pages in your application.
* Routes.razor: Not a standard file in default templates; it may contain routing configurations.
* _Imports.razor: A global import file for commonly used namespaces and components. It allows you to avoid repeating imports in every component.

### Program.cs
The entry point for your Blazor Server application. It configures the app's services and request pipeline.

### Properties Directory
* launchSettings.json: Configures the ASP.NET Core environment and settings for local development, like application URL and environment variables.

### appsettings Files
* appsettings.json and appsettings.Development.json: These files contain configuration settings for the application, such as connection strings and logging levels. The Development version is specifically for settings used while developing the app.

### wwwroot Directory
Contains static files served by the app, like CSS, JavaScript, and images:

* app.css: A stylesheet for the application.
* bootstrap: Contains Bootstrap CSS files for styling.
bin and obj Directories
These directories are generated by the build process:

* bin: Contains the compiled output of your application along with any dependencies.
* obj: Contains temporary objects and files used to compile the project.

### Analysis
The project structure you've shared is organized according to standard conventions for Blazor Server applications, facilitating maintainability and development. The separation of components and pages into distinct directories helps manage complexity as your application grows. The use of layouts and a navigation menu supports a consistent look and feel across the application, while the wwwroot directory serves as the home for static assets like stylesheets and images, crucial for the application's presentation layer.

The presence of both appsettings.json and appsettings.Development.json allows for flexible configuration management across different environments, enhancing the application's deployability and scalability.

This structure is well-suited for developing sophisticated web applications using the Blazor framework, leveraging .NET capabilities for server-side logic and SPA-like interactivity without extensive JavaScript.


## Blazor Server vs Blazor WebAssembly

For this .Net 8 Blazor project created with the 'blazor' template, it's not entirely clear whether it's a blazor server or blazor webassembly type of project.

Here is an in-depth analysis

The content of the Program.cs does not exactly match the conventional setup for either a standard Blazor WebAssembly or Blazor Server application as of my last update. The use of specific methods such as AddRazorComponents(), AddInteractiveServerComponents(), and MapRazorComponents<App>().AddInteractiveServerRenderMode() are not standard API calls in the default templates for Blazor applications available up to .NET 6.

However, given the context and the methods mentioned, it seems like the application is configured to use Razor components in a server-executed environment, which suggests a setup closer to Blazor Server. The references to server-side components and the interactive nature of the components indicate an application model that relies on server-side execution rather than a Blazor WebAssembly app, which typically uses builder.RootComponents.Add<App>("#app"); and a client-side static hosting model with index.html as the entry point.

Calls such as AddRazorComponents() and AddInteractiveServerComponents(), are not part of the standard Blazor API, implying either a custom extension method setup or a project that's leveraging experimental or less commonly used APIs. This could be part of a specialized framework or library that abstracts Blazor's standard behaviors for specific use cases or organizational preferences.

Additionally, the configuration:

Uses middleware commonly associated with server-side applications, like UseExceptionHandler, UseHsts, and UseHttpsRedirection.
Configures services and middleware for serving Razor components in an interactive server-rendered mode, which aligns with Blazor Server's architecture.
Does not show any configuration typical for serving a Blazor WebAssembly application, such as serving a static index.html file or referencing blazor.webassembly.js.

Conclusion
Based on the provided Program.cs content, the application appears to be structured similarly to a Blazor Server application, albeit with non-standard method names and configurations. This might indicate a customized Blazor Server setup or a specific framework or library usage that extends the basic Blazor Server functionality with additional capabilities or abstractions.


## Blazor Router and Navigation 

The project includes a Router.razor file:

```<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)" />
        <FocusOnNavigate RouteData="routeData" Selector="h1" />
    </Found>
</Router>
```

### Router explanation

The Router.razor file you've shared is crucial for handling client-side navigation within a Blazor application, whether it's a Blazor Server or Blazor WebAssembly app. The Router component works by intercepting browser navigation actions (like clicking links) and then matching the browser's URL to a route defined in one or more of your Razor components. Here's a breakdown of how the components within your Router.razor file work:

#### `<Router>` Component
* AppAssembly: Specifies the assembly to search for pages or components that can be navigated to. In this case, it's using typeof(Program).Assembly, which tells the router to look for routable components in the same assembly as the Program class, typically your main project assembly.

#### `<Found>` and `<NotFound>` Templates
Inside the `<Router>`, you can define what to render when a route is found (`<Found>`) or not found (`<NotFound>`). Your snippet only includes a `<Found>` section, which means it specifies what to do when a matching route is found:

* Context="routeData": This attribute declares a variable named routeData that holds information about the matched route. This variable is then used to pass route data to other components.

#### `<RouteView>` Component
* RouteData: This attribute receives the route data (routeData variable) from the context of the <Found> template. It uses this data to determine which Razor component corresponds to the current URL.

* DefaultLayout: Specifies the layout that should be used for pages that don't specify their own layout. It's set to use Layout.MainLayout, which means any page routed to by this Router will use MainLayout.razor as its layout unless the page specifies otherwise.

#### `<FocusOnNavigate>` Component
* RouteData: Just like with RouteView, this component receives the current route data. It's used here to determine when navigation has occurred.

* Selector: Specifies a CSS selector for an element to focus on when the route changes. In this case, it's set to focus on an element with the tag h1 when navigation occurs. This can improve usability and accessibility by directing the user's attention to the main heading of a new page after navigating.

#### Router Summary
This setup allows your Blazor application to handle routing client-side, improving the user experience by avoiding full page reloads when navigating between pages/components defined in your application. The use of Router with RouteView and optionally FocusOnNavigate provides a smooth, single-page application (SPA) feel, which is a core advantage of using Blazor for web development.


### Navigation explanation  

This section explains how the navigation actually works based on a `Router`'s setting or configuration. 

When a user clicks on the Counter link defined by the NavLink component with href="counter" in your Blazor application, several things happen behind the scenes to ensure that the correct Razor component is rendered for the /counter route. Hereâ€™s a step-by-step breakdown of the sequence of events:

1. NavLink Clicked
The NavLink component is a specialized link component provided by Blazor that integrates with the Blazor Router. When the user clicks on a NavLink, it instructs the Blazor Router to navigate to the specified href attribute (counter in this case) without causing a full page reload.
2. Routing
The Router component, which you would typically have defined in your App.razor file, takes over. It examines the URL path requested by the user (/counter) and attempts to find a matching route among the Razor components in your application.
3. Route Matching
Razor components can specify routes using the @page directive at the top of the file. The Router looks for a component with a @page "/counter" directive that matches the URL path.

For example, the Counter component (Counter.razor) might look something like this at the top of the file:

`@page "/counter"`

4. Component Rendering
Once the Router finds a matching component for the route (Counter.razor), it renders this component within the specified layout (if any) or the default layout as defined in the RouteView component of the Router.

If additional route parameters are defined and passed in the URL, Blazor automatically binds these parameters to the component's parameters, if they are properly defined.

5. Layout and Child Content
If the Counter.razor component is rendered within a layout (e.g., MainLayout.razor), the layout's content will wrap around the Counter component's output. This is how consistent application structures (like navigation menus, headers, and footers) are maintained across different views.
6. Focus Management (Optional)
If you're using the FocusOnNavigate component within your Router, focus will shift to the element specified by the selector in the FocusOnNavigate component after navigation is complete. This step is optional and is primarily used for accessibility purposes.

#### Navigation Summary
The NavLink component seamlessly integrates with the Blazor Router to enable client-side navigation that matches routes to Razor components based on their @page directives. This process allows Blazor to provide a Single Page Application (SPA) experience where different components (or "pages") can be loaded dynamically without the need for full page reloads, leading to a smoother user experience and faster transitions between views.

### SPA Behavior in Blazor - Observing in DevTools

When clicking a NavLink on this app, I would assume that no full page reload takes place. But, in DevTools, what I inspect is this: 
When I click the Counter link, under Network tab in devtools, I see a `fetch` request to the URL: `http://localhost:5028/counter`. It returns a 200. 
Does it mean it is not really a SPA app? 

Seeing a fetch request to http://localhost:5028/counter that returns a 200 status code when you click on the Counter link in a Blazor application might seem initially confusing, but it doesn't necessarily mean your application isn't functioning as a Single Page Application (SPA). Let's break down what's happening:

#### SPA
Blazor applications, whether Server or WebAssembly, are designed to operate as SPAs. This means navigation between components/pages does not cause a full browser refresh. Instead, Blazor intercepts click events on links (e.g., within NavLink components), prevents the default browser navigation behavior, and instead uses SignalR (Blazor Server) or client-side routing (Blazor WebAssembly) to update the URL and render the new content dynamically.

#### Fetch Requests in Blazor Server Applications
In Blazor Server applications, interactions between the browser and the server occur over a SignalR connection. This connection is used for all sorts of updates, including UI diffs, event handling, and navigation. However, you might see HTTP fetch requests in certain situations, such as:

* Initial Page Load: The first page load of a Blazor Server app involves fetching the page over HTTP, establishing the SignalR connection, and downloading the necessary .NET assemblies and other static assets.

* Server Pre-rendering: If your Blazor Server app is configured to pre-render on the server before establishing the SignalR connection, you might see fetch requests that load the initial HTML content.

* AJAX Calls: Any explicit AJAX calls made from your Blazor components, for example, to fetch data from APIs, will appear as separate fetch or XHR requests.

* Static Files or Navigation Fallback: Fetch requests might be observed for static files or in scenarios where the app is configured to serve a fallback page for routes not recognized by the server.

#### Interpretation of Fetch Requests
Seeing a fetch request specifically for /counter when clicking a link could be due to how the navigation is handled or configured in your app, especially if you're using custom mechanisms or libraries alongside Blazor's routing. Normally, client-side navigation in a Blazor app wouldn't result in a visible fetch request for the new page's URL in the network tab, because Blazor handles these navigations internally via SignalR (for Blazor Server) or through the browser's History API (for Blazor WebAssembly).

#### Diagnostics
Ensure SPA Behavior: Confirm that navigation is handled by Blazor's router and not by default browser behavior. Check for JavaScript errors in the console that might prevent Blazor's scripts from intercepting navigation events.
* Check for Misconfigurations: Ensure there are no misconfigurations in your Blazor app or server setup that could cause unintended HTTP requests for navigations.
* Review Custom Code: If you have custom JavaScript that interacts with navigation or fetches data, ensure it aligns with Blazor's SPA model.

* Observe Request/Response Headers: When I refresh the browser with a F5 or clicking inside the address bar, in devtools I can see the fetch 200 and in the 'Response' tab I can see an HTML that gets returned from the server.
When I click the nav link, in devtools I can see the fetch 200 and in the response tab it doesn't display any response data. The response header for this fetch is:

```
Blazor-Enhanced-Nav: allow
Cache-Control: no-cache, no-store, max-age=0
Content-Type: text/html; charset=utf-8
Date: Sun, 31 Mar 2024 05:17:33 GMT
Pragma: no-cache
Server: Kestrel
Ssr-Framing: 2f46cae8-42af-4851-bf93-5e953ea4c7e6
Transfer-Encoding: chunked
```

The only addition here comparing to the 'physical' page reload is `Ssr-Framing`.

Based on this observations and the details provided, it seems that the application is utilizing some form of enhanced navigation feature, possibly specific to a newer or experimental version of Blazor or an additional library. The presence of the *Blazor-Enhanced-Nav* and Ssr-Framing headers suggests a mechanism that optimizes or alters the standard navigation process in Blazor applications. Here's a breakdown of the behavior and what these headers might signify:

#### Enhanced Navigation in Blazor
Blazor applications, both Server and WebAssembly, are designed to operate as single-page applications (SPAs), where navigation does not cause a full page reload. Instead, Blazor intercepts link clicks and uses the browser's history API (in WebAssembly) or a SignalR connection (in Server) to update the URL and dynamically change the content without leaving the current page. This process is usually invisible to the network tab in developer tools, except for initial loads or explicit HTTP requests made by the application.

#### Observations
Page Refresh or Direct Navigation: When you refresh the browser or directly navigate to a URL, the server responds with the full HTML content for that page. This is expected behavior as it's the initial load of the application, requiring the server to send the complete HTML to start or resume the Blazor app.

* Clicking the Nav Link: When navigating using a link within the application, Blazor typically handles this without making a new HTTP request for the page content. However, you're observing a fetch request with a 200 status code but no visible response data, alongside specific headers (Blazor-Enhanced-Nav, Ssr-Framing), indicating a specialized handling of navigation.

#### Interpretation
* Blazor-Enhanced-Nav Header: This header suggests that the fetch request you're seeing is part of an "enhanced navigation" feature, possibly aimed at optimizing Blazor's navigation by prefetching, pre-rendering, or otherwise preparing the content in a way that differs from the standard SPA model.

* Ssr-Framing Header: The presence of this header, alongside a unique identifier, could indicate server-side preparation or framing of content for the requested route, potentially as part of server-side rendering (SSR) optimizations or to support specific client-side interactions.

#### Explanation
This behavior could be part of an optimization, experimental feature, or a custom implementation within your Blazor application or a library it uses. These features might aim to enhance the user experience by reducing perceived load times or integrating more closely with server-side capabilities. However, without specific documentation or source code, it's challenging to provide a detailed explanation of these mechanisms.

#### Conclusion
In a correctly configured Blazor app operating as an SPA, navigation between components/pages managed by Blazor's router should not result in traditional fetch requests for each page's URL. If you're observing such behavior, it may warrant a closer inspection of your application's configuration, custom scripts, or Blazor's handling of navigation events.

Furthermore, The fetch request observed during client-side navigation, characterized by specific response headers and lack of visible response data in developer tools, indicates an optimization or customization in your Blazor application's navigation handling. This could be a feature designed to enhance SPA behavior, possibly through techniques like prefetching, SSR, or content framing. Understanding the exact nature of these headers and their impact on navigation would require insight into the Blazor version or third-party libraries you're using, as they're not part of the standard Blazor documentation available up to my last update.

## CSS Isolation in Blazor
This blazor app includes a Blazor.styles.css which resides in the .\obj folder! 
`obj/Debug/net8.0/scopedcss/bundle/Blazor.styles.css`

Here how it works.
The Blazor.styles.css file found in the obj/Debug/net8.0/scopedcss/bundle/ directory is a product of Blazor's CSS isolation feature, which was introduced with .NET 5. This feature allows developers to scope CSS styles to individual components, preventing styles from unintentionally affecting other parts of the application. Here's how it works and how the file gets generated:

In Blazor, CSS isolation lets you associate a stylesheet with a specific Razor component. This is achieved by creating a CSS file with the same name as the Razor component but with a .css extension. For example, for a component named MyComponent.razor, you can create a MyComponent.razor.css file. The styles defined in this file will only apply to MyComponent.razor, thanks to Blazor's build process that rewrites and bundles these styles.

### Generation of Blazor.styles.css
When you build your Blazor project, the .NET build process automatically processes these scoped CSS files. Here's a simplified overview of the steps involved:

* Compilation: During the build, the .NET SDK identifies all .razor.css files associated with your Razor components.

* Transformation: Each identified .razor.css file is transformed. The build process generates unique scope identifiers for the styles within these files and rewrites the CSS selectors to match these scoped identifiers. This ensures that the styles only affect the corresponding component, regardless of the global CSS namespace.

* Bundling: All transformed, scoped CSS files are then bundled into a single CSS file. This bundled file is named Blazor.styles.css and is placed in the obj directory during the build process. The location you've noted, obj/Debug/net8.0/scopedcss/bundle/Blazor.styles.css, indicates that it's part of the build output for a debug build targeting .NET 8.0.

* Serving: When you run your Blazor application, this bundled CSS file is served alongside your other static files. The Blazor framework ensures that the Blazor.styles.css file is referenced in your app, applying all scoped styles as intended.

### Benefits of CSS Isolation
* Modularity: Developers can style components individually without worrying about global styles or conflicts with other components.
* Maintainability: It's easier to manage and update styles when they are closely associated with their respective components.
* Performance: Bundling all scoped styles into a single file reduces the number of HTTP requests needed to load component-specific styles, potentially improving load times.

CSS isolation in Blazor simplifies the task of styling components in a modular and conflict-free manner, enhancing both developer productivity and application maintainability.

